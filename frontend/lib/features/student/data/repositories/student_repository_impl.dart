import 'package:dartz/dartz.dart';
import 'package:sim_java_frontend/core/error/exceptions.dart';
import 'package:sim_java_frontend/core/error/failures.dart';
import 'package:sim_java_frontend/core/network/network_info.dart';
import 'package:sim_java_frontend/features/student/data/datasources/student_remote_data_source.dart';
import 'package:sim_java_frontend/features/student/domain/repositories/student_repository.dart';
import 'package:sim_java_frontend/features/student/data/models/student_model.dart';

class StudentRepositoryImpl implements StudentRepository {
  final StudentRemoteDataSource remoteDataSource;
  final NetworkInfo networkInfo;

  StudentRepositoryImpl({
    required this.remoteDataSource,
    required this.networkInfo,
  });

  @override
  Future<Either<Failure, List<StudentModel>>> getStudents({
    int page = 1,
    int limit = 10,
    String? searchQuery,
    String? sortBy,
    bool ascending = true,
  }) async {
    if (!await networkInfo.isConnected) {
      return Left(NetworkFailure());
    }

    try {
      final students = await remoteDataSource.getStudents(
        page: page,
        limit: limit,
        searchQuery: searchQuery,
        sortBy: sortBy,
        ascending: ascending,
      );
      return Right(students);
    } on ServerException catch (e) {
      return Left(ServerFailure(message: e.message));
    } on UnauthorizedException {
      return Left(UnauthorizedFailure());
    } on ForbiddenException {
      return Left(ForbiddenFailure());
    } on NotFoundException {
      return Left(NotFoundFailure());
    } catch (e) {
      return Left(ServerFailure(message: 'An unexpected error occurred'));
    }
  }

  @override
  Future<Either<Failure, StudentModel>> getStudentById(String id) async {
    if (!await networkInfo.isConnected) {
      return Left(NetworkFailure());
    }

    try {
      final student = await remoteDataSource.getStudentById(id);
      return Right(student);
    } on ServerException catch (e) {
      return Left(ServerFailure(message: e.message));
    } on UnauthorizedException {
      return Left(UnauthorizedFailure());
    } on ForbiddenException {
      return Left(ForbiddenFailure());
    } on NotFoundException {
      return Left(NotFoundFailure());
    } catch (e) {
      return Left(ServerFailure(message: 'Failed to load student'));
    }
  }

  @override
  Future<Either<Failure, StudentModel>> createStudent({
    required String nisn,
    required String name,
    required String email,
    String? phone,
    String? address,
    DateTime? birthDate,
    required String gender,
    required String className,
    String? photoUrl,
  }) async {
    if (!await networkInfo.isConnected) {
      return Left(NetworkFailure());
    }

    try {
      final student = StudentModel(
        id: '', // Will be generated by the server
        nisn: nisn,
        name: name,
        email: email,
        phone: phone,
        address: address,
        birthDate: birthDate,
        gender: gender,
        className: className,
        photoUrl: photoUrl,
        createdAt: DateTime.now(),
        updatedAt: DateTime.now(),
      );

      final createdStudent = await remoteDataSource.createStudent(student);
      return Right(createdStudent);
    } on ServerException catch (e) {
      if (e is ValidationException) {
        return Left(ValidationFailure(errors: e.errors));
      }
      return Left(ServerFailure(message: e.message));
    } on UnauthorizedException {
      return Left(UnauthorizedFailure());
    } on ForbiddenException {
      return Left(ForbiddenFailure());
    } catch (e) {
      return Left(ServerFailure(message: 'Failed to create student'));
    }
  }

  @override
  Future<Either<Failure, StudentModel>> updateStudent({
    required String id,
    String? nisn,
    String? name,
    String? email,
    String? phone,
    String? address,
    DateTime? birthDate,
    String? gender,
    String? className,
    String? photoUrl,
  }) async {
    if (!await networkInfo.isConnected) {
      return Left(NetworkFailure());
    }

    try {
      // First, get the current student data
      final currentStudent = await getStudentById(id);
      
      return currentStudent.fold(
        (failure) => Left(failure),
        (student) async {
          // Update only the fields that were provided
          final updatedStudent = student.copyWith(
            nisn: nisn,
            name: name,
            email: email,
            phone: phone,
            address: address,
            birthDate: birthDate,
            gender: gender,
            className: className,
            photoUrl: photoUrl,
            updatedAt: DateTime.now(),
          );
          
          try {
            final result = await remoteDataSource.updateStudent(
              id: id,
              student: updatedStudent,
            );
            return Right(result);
          } on ServerException catch (e) {
            if (e is ValidationException) {
              return Left(ValidationFailure(errors: e.errors));
            }
            return Left(ServerFailure(message: e.message));
          } on UnauthorizedException {
            return Left(UnauthorizedFailure());
          } on ForbiddenException {
            return Left(ForbiddenFailure());
          } on NotFoundException {
            return Left(NotFoundFailure());
          } catch (e) {
            return Left(ServerFailure(message: 'Failed to update student'));
          }
        },
      );
    } catch (e) {
      return Left(ServerFailure(message: 'Failed to update student'));
    }
  }

  @override
  Future<Either<Failure, void>> deleteStudent(String id) async {
    if (!await networkInfo.isConnected) {
      return Left(NetworkFailure());
    }

    try {
      await remoteDataSource.deleteStudent(id);
      return const Right(null);
    } on ServerException catch (e) {
      return Left(ServerFailure(message: e.message));
    } on UnauthorizedException {
      return Left(UnauthorizedFailure());
    } on ForbiddenException {
      return Left(ForbiddenFailure());
    } on NotFoundException {
      return Left(NotFoundFailure());
    } catch (e) {
      return Left(ServerFailure(message: 'Failed to delete student'));
    }
  }

  @override
  Future<Either<Failure, String>> uploadPhoto({
    required String studentId,
    required String filePath,
  }) async {
    if (!await networkInfo.isConnected) {
      return Left(NetworkFailure());
    }

    try {
      final photoUrl = await remoteDataSource.uploadPhoto(
        studentId: studentId,
        filePath: filePath,
      );
      return Right(photoUrl);
    } on ServerException catch (e) {
      return Left(ServerFailure(message: e.message));
    } on UnauthorizedException {
      return Left(UnauthorizedFailure());
    } on ForbiddenException {
      return Left(ForbiddenFailure());
    } catch (e) {
      return Left(ServerFailure(message: 'Failed to upload photo'));
    }
  }

  @override
  Future<Either<Failure, String>> exportStudents({
    String? searchQuery,
    String? sortBy,
    bool ascending = true,
  }) async {
    if (!await networkInfo.isConnected) {
      return Left(NetworkFailure());
    }

    try {
      final filePath = await remoteDataSource.exportStudents(
        searchQuery: searchQuery,
        sortBy: sortBy,
        ascending: ascending,
      );
      return Right(filePath);
    } on ServerException catch (e) {
      return Left(ServerFailure(message: e.message));
    } on UnauthorizedException {
      return Left(UnauthorizedFailure());
    } on ForbiddenException {
      return Left(ForbiddenFailure());
    } catch (e) {
      return Left(ServerFailure(message: 'Failed to export students'));
    }
  }
}
